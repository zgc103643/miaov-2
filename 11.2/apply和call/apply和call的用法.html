<!DOCTYPE html>
<html class="theme theme-white">
<head>
<meta charset="utf-8">
<title>apply和call的用法</title>
<link href="https://www.zybuluo.com/static/assets/template-theme-white.css" rel="stylesheet" media="screen">
<style type="text/css">

#wmd-preview h1  {
    color: #0077bb; /* 将标题改为蓝色 */
}</style>
</head>
<body class="theme theme-white">
<div id="wmd-preview" class="wmd-preview wmd-preview-full-reader"><div class="md-section-divider"></div><div class="md-section-divider"></div><h1 data-anchor-id="gcgv" id="apply和call的用法">apply和call的用法</h1><p data-anchor-id="mirc"><code>JS面向对象编程</code> <code>学习笔记</code></p><hr><div class="md-section-divider"></div><h3 data-anchor-id="cmuy" id="call-和-apply">call 和 apply</h3><p data-anchor-id="hnd5">EC3给Function的原型定义了两个方法，它们是 Function.prototype.call 和 Function.prototype.apply。在实际的开发中，特别是函数式编程风格的代码中，call和apply尤为重要。能熟练的使用这两个方法模式我们真正成为一名JavaScript程序员的重要一步。</p><hr><div class="md-section-divider"></div><h3 data-anchor-id="6kyl" id="call-和-apply-的区别">call 和 apply 的区别</h3><p data-anchor-id="5wny">它们的作用其实是一模一样的，区别仅仅在于传入的参数形式不同。</p><blockquote data-anchor-id="9hgr" class="white-blockquote">
  <ul>
  <li>apply 接受两个参数，第一个参数用来制定函数体内this的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply方法把这个集合中的元素作为参数传递给被调用的函数。</li>
  </ul>
</blockquote><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="gqex"><ol class="linenums"><li class="L0"><code><span class="kwd">var</span><span class="pln"> fn </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class="pln">b</span><span class="pun">,</span><span class="pln">c</span><span class="pun">){</span></code></li><li class="L1"><code><span class="pln">    alert</span><span class="pun">([</span><span class="pln">a</span><span class="pun">,</span><span class="pln">b</span><span class="pun">,</span><span class="pln">c</span><span class="pun">,]);</span><span class="pln">  </span><span class="com">// [1,2,3]</span></code></li><li class="L2"><code><span class="pun">};</span></code></li><li class="L3"><code><span class="pln">fn</span><span class="pun">.</span><span class="pln">apply</span><span class="pun">(</span><span class="kwd">null</span><span class="pun">,[</span><span class="lit">1</span><span class="pun">,</span><span class="lit">2</span><span class="pun">,</span><span class="lit">3</span><span class="pun">])</span></code></li></ol></pre><blockquote data-anchor-id="qgc8" class="white-blockquote">
  <ul>
  <li>call 传入的参数数量不固定，第一个参用来制定函数体内的this指向，从第二个参数开始，每个参数被依次传入函数体内。</li>
  </ul>
</blockquote><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="nfj0"><ol class="linenums"><li class="L0"><code><span class="kwd">var</span><span class="pln"> fn </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class="pln">b</span><span class="pun">,</span><span class="pln">c</span><span class="pun">){</span></code></li><li class="L1"><code><span class="pln">    alert</span><span class="pun">([</span><span class="lit">1</span><span class="pun">,</span><span class="lit">2</span><span class="pun">,</span><span class="lit">3</span><span class="pun">])</span></code></li><li class="L2"><code><span class="pun">}</span></code></li></ol></pre><blockquote data-anchor-id="cs4e" class="white-blockquote">
  <ul>
  <li>当使用 call 或者 apply 时，如果我们传入的第一个参数为null，函数体内的this会默认指向宿主对象，在浏览器中，如果使用严格模式，则还为null。</li>
  </ul>
</blockquote><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="tyqq"><ol class="linenums"><li class="L0"><code><span class="kwd">var</span><span class="pln"> fn </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(){</span></code></li><li class="L1"><code><span class="pln">    alert</span><span class="pun">(</span><span class="kwd">this</span><span class="pln"> </span><span class="pun">===</span><span class="pln"> window</span><span class="pun">)</span><span class="pln"> </span><span class="com">//true</span></code></li><li class="L2"><code><span class="pun">}</span></code></li><li class="L3"><code><span class="pln">fn</span><span class="pun">.</span><span class="pln">call</span><span class="pun">(</span><span class="kwd">null</span><span class="pun">)</span></code></li><li class="L4"><code></code></li><li class="L5"><code><span class="kwd">var</span><span class="pln"> fn2 </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(){</span></code></li><li class="L6"><code><span class="pln">    </span><span class="str">"use strict"</span></code></li><li class="L7"><code><span class="pln">    alert</span><span class="pun">(</span><span class="kwd">this</span><span class="pln"> </span><span class="pun">===</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="com">//true</span></code></li><li class="L8"><code><span class="pun">}</span></code></li><li class="L9"><code><span class="pln">fn2</span><span class="pun">.</span><span class="pln">call</span><span class="pun">(</span><span class="kwd">null</span><span class="pun">)</span></code></li></ol></pre><hr><div class="md-section-divider"></div><h3 data-anchor-id="18ak" id="call-和-apply-的用途">call 和 apply 的用途</h3><div class="md-section-divider"></div><h4 data-anchor-id="udcv" id="1改变this指向直接看代码">1.改变this指向，直接看代码</h4><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="cy4o"><ol class="linenums"><li class="L0"><code><span class="kwd">var</span><span class="pln"> obj1 </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code><span class="pln">    name</span><span class="pun">:</span><span class="str">"fq"</span></code></li><li class="L2"><code><span class="pun">};</span></code></li><li class="L3"><code><span class="kwd">var</span><span class="pln"> obj2 </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L4"><code><span class="pln">    name</span><span class="pun">:</span><span class="str">"mm"</span></code></li><li class="L5"><code><span class="pun">}</span></code></li><li class="L6"><code></code></li><li class="L7"><code><span class="pln">window</span><span class="pun">.</span><span class="pln">name </span><span class="pun">=</span><span class="pln"> </span><span class="str">'window'</span><span class="pun">;</span></code></li><li class="L8"><code></code></li><li class="L9"><code><span class="kwd">var</span><span class="pln"> getName </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(){</span></code></li><li class="L0"><code><span class="pln">    alert</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">name</span><span class="pun">)</span></code></li><li class="L1"><code><span class="pun">}</span></code></li><li class="L2"><code></code></li><li class="L3"><code><span class="pln">getName</span><span class="pun">()</span><span class="pln"> </span><span class="com">// window</span></code></li><li class="L4"><code><span class="pln">getName</span><span class="pun">.</span><span class="pln">call</span><span class="pun">(</span><span class="pln">obj1</span><span class="pun">)</span><span class="pln">  </span><span class="com">//fq</span></code></li><li class="L5"><code><span class="pln">getName</span><span class="pun">.</span><span class="pln">call</span><span class="pun">(</span><span class="pln">obj2</span><span class="pun">)</span><span class="pln">  </span><span class="com">//mm</span></code></li></ol></pre><blockquote data-anchor-id="jsn9" class="white-blockquote">
  <ul>
  <li>在实际开发中，经常会遇到this指向被不经意改变的场景，比如有一个div节点，div节点的onclick事件中的this本来是指向这个div的。</li>
  </ul>
</blockquote><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="7ddf"><ol class="linenums"><li class="L0"><code><span class="pln">document</span><span class="pun">.</span><span class="pln">getElementById</span><span class="pun">(</span><span class="str">'div'</span><span class="pun">).</span><span class="pln">onclick </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(){</span></code></li><li class="L1"><code><span class="pln">    alert</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">id</span><span class="pun">)</span><span class="pln">   </span><span class="com">//div</span></code></li><li class="L2"><code><span class="pun">}</span></code></li></ol></pre><blockquote data-anchor-id="c4x4" class="white-blockquote">
  <ul>
  <li>假设该事件函数中有一个内部的函数fn，在事件内部调用fn函数时，fn函数体内的this就指向了window，而不是我们预期的div，这个时候我们就可以用call 和 apply去改变this指向了。</li>
  </ul>
</blockquote><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="o2dd"><ol class="linenums"><li class="L0"><code><span class="pln">document</span><span class="pun">.</span><span class="pln">getElementById</span><span class="pun">(</span><span class="str">'div'</span><span class="pun">).</span><span class="pln">onclick </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(){</span></code></li><li class="L1"><code><span class="pln">    alert</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">id</span><span class="pun">)</span><span class="pln">   </span><span class="com">//div</span></code></li><li class="L2"><code><span class="pln">    </span><span class="kwd">var</span><span class="pln"> fn </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(){</span></code></li><li class="L3"><code><span class="pln">        alert</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">id</span><span class="pun">)</span><span class="pln">  </span><span class="com">//undefined</span></code></li><li class="L4"><code><span class="pln">    </span><span class="pun">};</span></code></li><li class="L5"><code><span class="pln">    fn</span><span class="pun">();</span></code></li><li class="L6"><code><span class="pun">};</span></code></li><li class="L7"><code></code></li><li class="L8"><code><span class="com">//之前都是保存一下this，更优雅的做法可以这样</span></code></li><li class="L9"><code><span class="pln">document</span><span class="pun">.</span><span class="pln">getElementById</span><span class="pun">(</span><span class="str">'div'</span><span class="pun">).</span><span class="pln">onclick </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(){</span></code></li><li class="L0"><code><span class="pln">    alert</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">id</span><span class="pun">)</span><span class="pln">   </span><span class="com">//div</span></code></li><li class="L1"><code><span class="pln">    </span><span class="kwd">var</span><span class="pln"> fn </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(){</span></code></li><li class="L2"><code><span class="pln">        alert</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">id</span><span class="pun">)</span><span class="pln">  </span><span class="com">//undefined</span></code></li><li class="L3"><code><span class="pln">    </span><span class="pun">};</span></code></li><li class="L4"><code><span class="pln">    fn</span><span class="pun">.</span><span class="pln">call</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">);</span></code></li><li class="L5"><code><span class="pun">};</span></code></li></ol></pre><blockquote data-anchor-id="bcdu" class="white-blockquote">
  <ul>
  <li>案例:内部丢失的this <br>
  或许你某天会觉得 document.getElementById函数有点太长了,也去你会这么做:</li>
  </ul>
</blockquote><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="e5bp"><ol class="linenums"><li class="L0"><code><span class="kwd">var</span><span class="pln"> getId </span><span class="pun">=</span><span class="pln"> document</span><span class="pun">.</span><span class="pln">getElementById</span><span class="pun">;</span></code></li><li class="L1"><code><span class="pln">getId</span><span class="pun">(</span><span class="str">'div'</span><span class="pun">);</span><span class="pln">  </span><span class="com">//但是会报错...</span></code></li></ol></pre><p data-anchor-id="nki1">这是因为document.getElementById内部的this实际上在调用的时候 是需要指向document的,所以我们需要手动修正this</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="bn0i"><ol class="linenums"><li class="L0"><code><span class="pln">document</span><span class="pun">.</span><span class="pln">getElementById </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">fn</span><span class="pun">){</span></code></li><li class="L1"><code><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(){</span></code></li><li class="L2"><code><span class="pln">        </span><span class="kwd">return</span><span class="pln"> fn</span><span class="pun">.</span><span class="pln">apply</span><span class="pun">(</span><span class="pln">document</span><span class="pun">,</span><span class="pln">arguments</span><span class="pun">);</span></code></li><li class="L3"><code><span class="pln">    </span><span class="pun">}</span></code></li><li class="L4"><code><span class="pun">})(</span><span class="pln">document</span><span class="pun">.</span><span class="pln">getElementById</span><span class="pun">)</span></code></li></ol></pre><p data-anchor-id="iiq5">对于上面的代码，等式右边的函数自执行的结果为内部的匿名函数，但是执行的时候相当于先把之前的 document.getElementById 保存到fn中了，如下：</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="yofr"><ol class="linenums"><li class="L0"><code></code></li><li class="L1"><code><span class="kwd">var</span><span class="pln"> fn </span><span class="pun">=</span><span class="pln"> document</span><span class="pun">.</span><span class="pln">getElementById</span><span class="pun">;</span></code></li><li class="L2"><code><span class="pln">document</span><span class="pun">.</span><span class="pln">getElementById </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(){</span></code></li><li class="L3"><code><span class="pln">    </span><span class="kwd">return</span><span class="pln"> fn</span><span class="pun">.</span><span class="pln">apply</span><span class="pun">(</span><span class="pln">document</span><span class="pun">,</span><span class="pln">arguments</span><span class="pun">)</span><span class="pln"> </span><span class="com">//传进来的实参在arguments中</span></code></li><li class="L4"><code><span class="pun">}</span></code></li></ol></pre><p data-anchor-id="6zv5">然后当用变量再次存储document.getElementById的时候这时候实际运行的是上面第二个等式后面的函数，然后返回的之前存储的fn运行的结果，但是在函数执行的时候，通过apply修正了this指向document。</p><div class="md-section-divider"></div><h4 data-anchor-id="pnb8" id="2functionprototypebind">2.Function.prototype.bind</h4><p data-anchor-id="gc9v">大部分高级浏览器都实现了内置的Function.prototype.bind方法，用来指定内部的this指向，它返回一个修改this之后的函数，但是并不会想apply和 <br>
call那样直接执行函数，来看下面的代码:</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="zysd"><ol class="linenums"><li class="L0"><code><span class="kwd">var</span><span class="pln"> obj </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code><span class="pln">    fn</span><span class="pun">(){</span></code></li><li class="L2"><code><span class="pln">        console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">);</span></code></li><li class="L3"><code><span class="pln">    </span><span class="pun">}</span></code></li><li class="L4"><code><span class="pun">}</span></code></li><li class="L5"><code><span class="pln">setTimeout</span><span class="pun">(</span><span class="pln">obj</span><span class="pun">.</span><span class="pln">fn</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1000</span><span class="pun">);</span><span class="pln">  </span><span class="com">//window</span></code></li><li class="L6"><code><span class="pln">setTimeout</span><span class="pun">(</span><span class="pln">obj</span><span class="pun">.</span><span class="pln">fn</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="pln">obj</span><span class="pun">),</span><span class="pln"> </span><span class="lit">1000</span><span class="pun">);</span><span class="pln"> </span><span class="com">//obj</span></code></li></ol></pre><p data-anchor-id="nqrz">那么咱们看看bind的实现原理是什么</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="gsh8"><ol class="linenums"><li class="L0"><code><span class="typ">Function</span><span class="pun">.</span><span class="pln">prototype</span><span class="pun">.</span><span class="pln">bind </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">context</span><span class="pun">){</span></code></li><li class="L1"><code><span class="pln">    </span><span class="kwd">var</span><span class="pln"> _this </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">;</span></code></li><li class="L2"><code><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(){</span></code></li><li class="L3"><code><span class="pln">        </span><span class="kwd">return</span><span class="pln"> _this</span><span class="pun">.</span><span class="pln">apply</span><span class="pun">(</span><span class="pln">context</span><span class="pun">,</span><span class="pln">arguments</span><span class="pun">);</span></code></li><li class="L4"><code><span class="pln">    </span><span class="pun">}</span></code></li><li class="L5"><code><span class="pun">}</span></code></li></ol></pre><p data-anchor-id="hs61">也就是先把 之前的函数的引用保存起来，然后返回一个新的函数，只不过这个函数在执行的时候 返回的是保存的引用改变this之后的执行结果。</p><div class="md-section-divider"></div><h4 data-anchor-id="7eyo" id="3借用其它对象的方法">3.借用其它对象的方法</h4><blockquote data-anchor-id="ckqi" class="white-blockquote">
  <p>我们都知道，杜鹃既不会筑巢，也不会孵雏，而是把自己的蛋寄托给云雀等其他鸟类，让他们代为孵化和养育。同样，在JavaScript中也存在类似的借用现象。</p>
</blockquote><p data-anchor-id="xyll">借用方法的第一种场景是“借用构造函数”，通过这种技术，可以实现一些类似继承的效果：</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="0htm"><ol class="linenums"><li class="L0"><code><span class="kwd">var</span><span class="pln"> A </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">name</span><span class="pun">){</span></code></li><li class="L1"><code><span class="pln">    console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">name</span><span class="pun">)</span></code></li><li class="L2"><code><span class="pun">};</span></code></li><li class="L3"><code><span class="kwd">var</span><span class="pln"> B </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(){</span></code></li><li class="L4"><code><span class="pln">    A</span><span class="pun">.</span><span class="pln">apply</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">,</span><span class="pln">agruments</span><span class="pun">);</span></code></li><li class="L5"><code><span class="pun">};</span></code></li><li class="L6"><code></code></li><li class="L7"><code><span class="pln">B</span><span class="pun">.</span><span class="pln">prototype</span><span class="pun">.</span><span class="pln">getName </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(){</span></code></li><li class="L8"><code><span class="pln">    console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">name</span><span class="pun">)</span></code></li><li class="L9"><code><span class="pun">}</span></code></li><li class="L0"><code><span class="kwd">var</span><span class="pln"> b </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> B</span><span class="pun">(</span><span class="str">'momo'</span><span class="pun">);</span></code></li><li class="L1"><code><span class="pln">b</span><span class="pun">.</span><span class="pln">getName</span><span class="pun">();</span><span class="pln">  </span><span class="com">// momo</span></code></li></ol></pre><p data-anchor-id="v8os">借用方法的第二种场景跟我们更加密切。 <br>
函数的参数列表arguments是一个类数组的对象，虽然它也有“小标”,但它并非正在的数组，所以不能像数组一样进行排序操作或者往集合里面添加一个新元素。这种情况下，我们常常会借用Array.prototype对象上的方法。比如想往arguments中添加一个新元素，通常会借用Array.prototype.push;</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="qby3"><ol class="linenums"><li class="L0"><code><span class="pun">(</span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(){</span></code></li><li class="L1"><code><span class="pln">    </span><span class="typ">Array</span><span class="pun">.</span><span class="pln">prototype</span><span class="pun">.</span><span class="pln">push</span><span class="pun">.</span><span class="pln">call</span><span class="pun">(</span><span class="pln">arguments</span><span class="pun">,</span><span class="lit">3</span><span class="pun">);</span></code></li><li class="L2"><code><span class="pln">    console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">arguments</span><span class="pun">);</span><span class="pln">   </span><span class="com">// [1, 2, 3]</span></code></li><li class="L3"><code><span class="pun">})(</span><span class="lit">1</span><span class="pun">,</span><span class="lit">2</span><span class="pun">)</span></code></li></ol></pre><p data-anchor-id="iko7">在操作arguments的时候我们经常频繁的去找Array.prototype对象借用方法。 <br>
想把arguments转换成真正的数组的时候，可以借用Array.prototype.slice方法，想截取arguments列表中第一个元素的时候，由可以借用Array.prototype.shift方法。这些借用其实很常见，没什么好说的，那么他们内部实现的机制原理是什么呢？ 不妨咱们翻开v8引擎的源码来看看吧！</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="90vc"><ol class="linenums"><li class="L0"><code><span class="kwd">function</span><span class="pln"> </span><span class="typ">ArrayPush</span><span class="pun">(){</span></code></li><li class="L1"><code><span class="pln">    </span><span class="kwd">var</span><span class="pln"> n </span><span class="pun">=</span><span class="pln"> TO_UINT32</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">length</span><span class="pun">);</span><span class="pln"> </span><span class="com">//被push对象的length</span></code></li><li class="L2"><code><span class="pln">    </span><span class="kwd">var</span><span class="pln"> m </span><span class="pun">=</span><span class="pln"> </span><span class="pun">%</span><span class="typ">_ArgumentsLength</span><span class="pun">();</span><span class="pln"> </span><span class="com">//push的参数个数</span></code></li><li class="L3"><code><span class="pln">    </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> i</span><span class="pun">=</span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">&lt;</span><span class="pln">m</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++){</span></code></li><li class="L4"><code><span class="pln">        </span><span class="kwd">this</span><span class="pun">[</span><span class="pln">i</span><span class="pun">+</span><span class="pln">n</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">%</span><span class="typ">_Arguments</span><span class="pun">[</span><span class="pln">i</span><span class="pun">];</span><span class="pln"> </span><span class="com">//赋值元素</span></code></li><li class="L5"><code><span class="pln">    </span><span class="pun">}</span></code></li><li class="L6"><code><span class="pln">    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">length </span><span class="pun">=</span><span class="pln"> m </span><span class="pun">+</span><span class="pln"> n</span><span class="pun">;</span></code></li><li class="L7"><code><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">length</span><span class="pun">;</span></code></li><li class="L8"><code><span class="pun">}</span></code></li></ol></pre><p data-anchor-id="cqi8">通过上面这段代码可以看到，Array.prototype.push实际上是一个属性赋值的过过程，把参数按照下标依次添加到被push的对象上面，顺便修改了这个对象的length属性。至于被修改的对象是谁，到底是个数组还是个对象，这个并不重要。</p><p data-anchor-id="qne9">那么改写成 JavaScript 的代码 push 应该是这样的</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="a768"><ol class="linenums"><li class="L0"><code><span class="kwd">var</span><span class="pln"> </span><span class="typ">Utils</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code><span class="pln">    push</span><span class="pun">(){</span></code></li><li class="L2"><code><span class="pln">        </span><span class="kwd">var</span><span class="pln"> n </span><span class="pun">=</span><span class="pln"> arguments</span><span class="pun">[</span><span class="lit">0</span><span class="pun">].</span><span class="pln">length </span><span class="pun">||</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span></code></li><li class="L3"><code><span class="pln">            m </span><span class="pun">=</span><span class="pln"> arguments</span><span class="pun">.</span><span class="pln">length </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span></code></li><li class="L4"><code></code></li><li class="L5"><code><span class="pln">        </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> i</span><span class="pun">=</span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> m</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++){</span></code></li><li class="L6"><code><span class="pln">            arguments</span><span class="pun">[</span><span class="lit">0</span><span class="pun">][</span><span class="pln">i</span><span class="pun">+</span><span class="pln">n</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> arguments</span><span class="pun">[</span><span class="pln">i </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">]</span></code></li><li class="L7"><code><span class="pln">        </span><span class="pun">}</span></code></li><li class="L8"><code></code></li><li class="L9"><code><span class="pln">        arguments</span><span class="pun">[</span><span class="lit">0</span><span class="pun">].</span><span class="pln">length </span><span class="pun">=</span><span class="pln"> m </span><span class="pun">+</span><span class="pln"> n</span><span class="pun">;</span></code></li><li class="L0"><code></code></li><li class="L1"><code><span class="pln">        </span><span class="kwd">return</span><span class="pln"> arguments</span><span class="pun">[</span><span class="lit">0</span><span class="pun">].</span><span class="pln">length</span><span class="pun">;</span></code></li><li class="L2"><code><span class="pln">    </span><span class="pun">}</span></code></li><li class="L3"><code><span class="pun">}</span></code></li><li class="L4"><code></code></li><li class="L5"><code><span class="kwd">var</span><span class="pln"> o </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{};</span></code></li><li class="L6"><code><span class="typ">Utils</span><span class="pun">.</span><span class="pln">push</span><span class="pun">(</span><span class="pln">o</span><span class="pun">,</span><span class="lit">1</span><span class="pun">,</span><span class="lit">2</span><span class="pun">,</span><span class="lit">3</span><span class="pun">);</span><span class="pln"> </span><span class="com">// 3</span></code></li><li class="L7"><code><span class="pln">console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">o</span><span class="pun">);</span><span class="pln"> </span><span class="com">//Object {0: 1, 1: 2, 2: 3, length: 3}</span></code></li></ol></pre><p data-anchor-id="1z5l">由此可以推断我们可以把“任意”的对象传入Array.prototype.push。为什么要把“任意”这两个字加引号呢？ 因为这个对象其实还要满足2各条件：</p><blockquote data-anchor-id="lsnr" class="white-blockquote">
  <ul>
  <li>对象本身可以存储属性</li>
  <li>对象的length属性可读可写</li>
  </ul>
</blockquote><p data-anchor-id="rwc1">对于第一个条件，对象本身存取属性并没有问题，但是如果借用Array.prototype.push方法的不是一个Object类型数据，而是一个number类型的数据呢？我们无法在number身上存取其他数据，那么从下面的测试代码可以发现，一个number类型的数据不可能借用到这个方法：</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="18vq"><ol class="linenums"><li class="L0"><code><span class="kwd">var</span><span class="pln"> a </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span></code></li><li class="L1"><code><span class="typ">Array</span><span class="pun">.</span><span class="pln">prototype</span><span class="pun">.</span><span class="pln">push</span><span class="pun">.</span><span class="pln">call</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class="str">'first'</span><span class="pun">);</span></code></li><li class="L2"><code><span class="pln">alert</span><span class="pun">(</span><span class="pln">a</span><span class="pun">.</span><span class="pln">length</span><span class="pun">)</span><span class="pln">  </span><span class="com">// undefined</span></code></li><li class="L3"><code><span class="pln">alert</span><span class="pun">(</span><span class="pln">a</span><span class="pun">[</span><span class="lit">0</span><span class="pun">])</span><span class="pln"> </span><span class="com">//undefined</span></code></li></ol></pre><p data-anchor-id="1cdw">对于第二个条件，函数的length属性就是只读的，表示形参的个数，我们尝试把一个函数当做this传入Array.prototype.push：</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="x4n6"><ol class="linenums"><li class="L0"><code><span class="kwd">var</span><span class="pln"> fn </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(){};</span></code></li><li class="L1"><code><span class="typ">Array</span><span class="pun">.</span><span class="pln">prototype</span><span class="pun">.</span><span class="pln">push</span><span class="pun">.</span><span class="pln">call</span><span class="pun">(</span><span class="pln">fn</span><span class="pun">,</span><span class="str">'first'</span><span class="pun">);</span><span class="pln"> </span><span class="com">//报错</span></code></li><li class="L2"><code><span class="pln">alert</span><span class="pun">(</span><span class="pln">fn</span><span class="pun">.</span><span class="pln">length</span><span class="pun">);</span><span class="pln">  </span></code></li></ol></pre></div>
</body>
</html>